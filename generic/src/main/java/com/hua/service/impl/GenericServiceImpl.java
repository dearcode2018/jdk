/**
 * GenericServiceImpl.java
 * @author  qye.zheng
 * 	version 1.0
 */
package com.hua.service.impl;

import com.hua.service.GenericService;

/**
 * GenericServiceImpl
 * 描述: 
 * @author  qye.zheng
 */
public final class GenericServiceImpl extends CoreServiceImpl implements
		GenericService
{

	/**
	 
	 泛型的引入（Generics）
	1）JDK 1.5引入泛型。泛型又称为参数类型化或模板，是和继承不同而互补的一种组件复用机制。
	2）继承和泛型的不同之处在于——在一个系统中，继承层次是垂直方向，从抽象到具体，而泛型是水平方向的。
	3）当运用继承，不同的类型将拥有相同的接口，并获得了多态性；当运用泛型，将拥有许多不同的类型，并得以相同的算法作用在它们身上。
	4）一般说来，当类型与实现方法无关时，用泛型；否则，用继承。
	5）使用泛型建立容器数据类型。
	6）类型参数：<泛型参数1, 泛型参数2, ...>
	7）编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其擦除（Erasure）
	8）使用泛型，可以安全写入数据和读取数据，不存在类型转换隐患和不明确问题。
	 
	 
	 类型变量
	1）尖括号里面声明类型变量：<类型变量>
	2）泛型[普通类/抽象类/接口/注解/枚举/普通方法/构造方法]声明
	3）泛型类/接口：
	权限符class/interface 类/接口<泛型变量1,泛型变量2...> {}
	泛型变量做参数也称为类型参数。
	4）泛型方法/构造器(构造方法)：
	权限符修饰符<泛型变量1,泛型变量2...>返回值方法名(参数){} // 在返回值类型之前声明了类型变量之后，返回值类型/方法参数类型/方法体中数据类型，都能使用这些泛型变量了。
	5）
	///
	1)	
	类型安全，泛型参数→固定类型
	2)	注意问题
	①泛型基类型允许多态；泛型_参数类型，不允许多态.
	3)	所有泛型都是编译时_概念；JVM是不知道泛型的，加泛型只是通知编译器进行相应检查.
	4)	泛型_实现
	///
	泛型_通配符
	1）本类及其子类：<? extends ClassName>
	2）本类及其父类：<? super ClassName>
	3）向上造型：
	C<子类>是C<? extends 父类>的子类型
	4）向下造型：
	C<父类>是C<? super 子类>的子类型
	5）通配类型：C<?>不确定？到底是什么，因此编译器对C<?>中的元素只能用Object来引用，只能读，读成Object类型。
	6）<标识符>		<?>			<? extends Xx>		<? super Xx>
	///
	（不限制类型）：
	<?>：表示可以接收所有类型（可变类型）
	<T>：接收一个指定类型参数（类型参数：变量）
	（固定类型）：
	<String>：指定是什么类型（类型参数：常量）
	（限制类型）：
	<? extends Object>：接收什么样的类型
	<? super Integer>：接收什么样的类型
	<? extends T>：接收的类型是参数类型的子类
	<? super T>：接收的类型是参数类型的父类
	///
	泛型方法
	示例：
	public <T> T test(T t) {return t;}
	///
	<T1,T2, T3, ...>可出现：
	泛型类：
	1）广义类(5种)：普通类/抽象类/接口/注解/枚举。
	类型声明可以出现在：编译/方法参数/方法返回值类型声明。
	2）泛型类：写在类名后面,尖括号里面的类型参数是对象级的，与类的对象绑在一起。因此，如果是调用该类的类级成员，直接类名.成员名即可，与泛型无关。如果该类作为类型出现在编译类型声明、方法参数类型声明、方法返回值类型声明，还有new类名<T1, T2, ...>时需要带上泛型参数。
	类型出现、new一个对象，都需要具体的已知类型作为参数传入。
	3）总之，在泛型类中，<>泛型参数列表的作用相当于一个方法的参数列表。使用了泛型之后，该类就必须除了在类级成员的引用方面，其他都需要与泛型参数共进退，泛型参数都有具体类型值。
	泛型中，警告也不能出现。
	4）
	///
	泛型方法
	在方法的返回值之前声明一个泛型参数列表
	public <T1, T2, T3, ...>返回类型方法名(...) {...}
	类级方法只能使用自身声明的泛型参数，而对象级方法不但可以自定义泛型参数，也可以使用类声明的泛型参数。
	///
	通配符_
	?只能出现在方法参数的声明中：
	例如：List<? extends Number>,指明<>里面的参数必须符合 “? extends Number”条件。
	?声明表示只使用一次，而无需给一个名字。
	形式：
	<?>：表示没有限定条件,不能用具体值取代，直接表示所有的值。
	<? extends T1>：必须是具体值，而且该子必须满足指定的限定条件。
	<? super T1>：同上。
	T1可以是方法自身声明的，也可以是类声明的。
	///
	加限定(extends/super)
	在哪里声明的泛型参数，就在哪里加上限定。
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 */
	
	/**
	 
	 泛型变量: 可以让使用者，指定具体的类型.
	 
	 类/接口声明的泛型变量，只能在动态方法中
	 使用，静态方法只能使用自身声明的泛型
	 变量.
	 
	 
	 继承含有泛型变量声明的类，子类可以
	 继续保持泛型变量的声明，将泛型变量的
	 实例化值交给构造者或者下一级继承者去
	 实现，下一级继承者也可以选择不实现
	 或者部分实现或者全部实现，
	 但是构造对象的时候，必须实例化泛型
	 变量，该类才能正常使用.
	 
	 下一级继承者: 全部/部分/都不 实例化上一级的
	 泛型变量，但是构造该对象的使用者需要全部
	 实例化该类直接提供的泛型变量，在构造的时候
	 没有实例化泛型变量，则默认使用Object来代替，
	 这种行为将导致类型不安全，因此不推荐这种做法，
	 而且只能全部实例化或者全部不实例化，不能部分
	 实例化.
	 
	 
	 继承父类、实现接口，其泛型变量需要一一对应去
	 实现或保持.
	 子类名称后<>尖括号中 写的是所继承和实现接口
	 的所有泛型变量列表，继承的类的后面写的是继承
	 该类的所有泛型变量列表，接口后面写的是实现该
	 接口的所有泛型变量列表
	 
	 静态方法的泛型只能通过参数类型的方式传入方法，
	 通过参数可以实例化泛型变量，不然，静态方法声明
	 的泛型变量无法实例化，导致内部实现出问题.
	 
	 
	 <?> 指容纳任意类型，书写方式: Type<?> 表示可以接收 Type<任意具体类型>
	 <T> 指容纳实际某种类型，书写方式: 类型/方法声明中使用；或以具体值形式
	 写成值类型声明
	 
	 <?> 在某些情况下可以指Object类型
	 
	 */
	
	/**
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 */
}
